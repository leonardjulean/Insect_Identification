import streamlit as st
import numpy as np
import cv2
import tensorflow as tf
from tensorflow.keras.models import load_model
from tensorflow.keras.preprocessing import image
from PIL import Image
import json
import os

# Configurarea paginii
st.set_page_config(
    page_title="Recunoa»ôtere Insecte",
    page_icon="üêù",
    layout="wide"
)

# Func»õie de √ÆncƒÉrcare model
@st.cache_resource
def load_custom_model(model_path):
    """Load trained model and retrieve class names."""
    model = load_model(model_path)
    
    # Get input size dynamically from the model
    input_shape = model.input_shape[1:3]  # Extract (height, width)
    
    # Get number of classes from output layer
    num_classes = model.output_shape[1]
    
    return model, input_shape, num_classes

# Func»õie de predic»õie
def predict_insect(model, img, class_names, img_size):
    """Predict insect species from an image using the provided model."""
    
    # Convert PIL image to OpenCV format
    img_cv2 = np.array(img)
    img_cv2 = cv2.cvtColor(img_cv2, cv2.COLOR_RGB2BGR)
    img_cv2 = cv2.cvtColor(img_cv2, cv2.COLOR_BGR2RGB)  # Convert back to RGB

    # Resize image based on model's input size
    img_resized = cv2.resize(img_cv2, img_size)
    
    # Preprocess for model
    img_array = img_resized / 255.0
    img_array = np.expand_dims(img_array, axis=0)

    # Model prediction
    prediction = model.predict(img_array)
    class_index = np.argmax(prediction)
    confidence = np.max(prediction)

    # Convert to grayscale and detect edges
    gray = cv2.cvtColor(img_cv2, cv2.COLOR_RGB2GRAY)
    blurred = cv2.GaussianBlur(gray, (5, 5), 0)
    edges = cv2.Canny(blurred, 50, 120)

    # Find contours
    contours, _ = cv2.findContours(edges, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
    
    if contours:
        # Filter out very small and very large contours
        valid_contours = [cnt for cnt in contours if 500 < cv2.contourArea(cnt) < 100000]

        if valid_contours:
            # Find the best contour (biggest, but within a reasonable range)
            largest_contour = max(valid_contours, key=cv2.contourArea)
            x, y, w, h = cv2.boundingRect(largest_contour)

            # Ensure bounding box stays within image bounds
            img_h, img_w = img_cv2.shape[:2]
            x = max(0, min(x, img_w - 1))
            y = max(0, min(y, img_h - 1))
            w = max(1, min(w, img_w - x))
            h = max(1, min(h, img_h - y))

            # Draw a GREEN bounding box
            cv2.rectangle(img_cv2, (x, y), (x + w, y + h), (0, 255, 0), 3)

    # Get predicted label
    predicted_label = class_names[class_index]
    
    return img_cv2, predicted_label, confidence, prediction

# Titlu principal »ôi descriere
st.title("üêù Recunoa»ôtere Insecte")
st.write("√éncƒÉrca»õi o imagine pentru a identifica tipul de insectƒÉ")

# Sidebar pentru √ÆncƒÉrcarea modelului
st.sidebar.header("Configurare Model")

# Calea cƒÉtre model - folosim calea relativƒÉ
MODEL_PATH = st.sidebar.text_input(
    "Calea cƒÉtre modelul antrenat (.h5)", 
    value="./model/mobilenet_insect_classifier.h5"
)

# Calea cƒÉtre fi»ôierul class_names.json
CLASS_NAMES_PATH = st.sidebar.text_input(
    "Calea cƒÉtre numele claselor (JSON)",
    value="./model/class_names.json"
)

# VerificƒÉm dacƒÉ fi»ôierele existƒÉ »ôi altfel √ÆncercƒÉm sƒÉ le gƒÉsim
if not os.path.exists(MODEL_PATH):
    # √éncercƒÉm sƒÉ gƒÉsim orice fi»ôier .h5 √Æn directorul curent sau √Æn subdirectoare
    h5_files = []
    for root, dirs, files in os.walk('.'):
        for file in files:
            if file.endswith('.h5'):
                h5_files.append(os.path.join(root, file))
    
    if h5_files:
        MODEL_PATH = h5_files[0]  # Folosim primul model gƒÉsit
        st.sidebar.info(f"Model gƒÉsit automat: {MODEL_PATH}")

if not os.path.exists(CLASS_NAMES_PATH):
    # √éncercƒÉm sƒÉ gƒÉsim fi»ôierul class_names.json √Æn directorul curent sau √Æn subdirectoare
    json_files = []
    for root, dirs, files in os.walk('.'):
        for file in files:
            if file == 'class_names.json':
                json_files.append(os.path.join(root, file))
    
    if json_files:
        CLASS_NAMES_PATH = json_files[0]  # Folosim primul fi»ôier gƒÉsit
        st.sidebar.info(f"Fi»ôier class_names.json gƒÉsit automat: {CLASS_NAMES_PATH}")

# √éncƒÉrcƒÉm numele claselor din fi»ôierul JSON
class_names = None
if os.path.exists(CLASS_NAMES_PATH):
    try:
        with open(CLASS_NAMES_PATH, 'r') as f:
            class_names = json.load(f)
        st.sidebar.success(f"‚úÖ Nume de clase √ÆncƒÉrcate: {len(class_names)}")
    except Exception as e:
        st.sidebar.error(f"‚ùå Eroare la √ÆncƒÉrcarea numelor de clase: {str(e)}")
else:
    st.sidebar.warning("‚ö†Ô∏è Fi»ôierul cu numele claselor nu a fost gƒÉsit. Se vor folosi nume generice.")
    # Daca nu exista fisierul, cream un demo cu nume generice
    class_names = ["AlbinƒÉ", "G√¢ndac", "Fluture", "LibelulƒÉ", "FurnicƒÉ", "»ö√¢n»õar", "PƒÉianjen"]
    st.sidebar.info("Se folosesc nume de clase demo pentru testare.")

# √éncƒÉrcare model
model_loaded = False
if os.path.exists(MODEL_PATH):
    try:
        with st.spinner("Se √ÆncarcƒÉ modelul..."):
            model, img_size, num_classes = load_custom_model(MODEL_PATH)
            
            # DacƒÉ nu avem nume de clase, creƒÉm nume generice
            if class_names is None:
                class_names = [f"Insecta {i+1}" for i in range(num_classes)]
            
            # Verificare dacƒÉ numƒÉrul de clase se potrive»ôte
            if num_classes != len(class_names):
                st.sidebar.warning(f"‚ö†Ô∏è Aten»õie: Modelul are {num_classes} clase, dar lista √ÆncƒÉrcatƒÉ are {len(class_names)}.")
                # Ajustare automatƒÉ a listei
                if num_classes < len(class_names):
                    class_names = class_names[:num_classes]
                else:
                    class_names = class_names + [f"Insecta {i+len(class_names)+1}" for i in range(len(class_names), num_classes)]
                
            model_loaded = True
            st.sidebar.success(f"‚úÖ Model √ÆncƒÉrcat cu succes: {os.path.basename(MODEL_PATH)}")
    except Exception as e:
        st.sidebar.error(f"‚ùå Eroare la √ÆncƒÉrcarea modelului: {str(e)}")
else:
    st.sidebar.warning("‚ö†Ô∏è Modelul nu a fost gƒÉsit. √éncerca»õi sƒÉ verifica»õi calea sau sƒÉ uploada»õi modelul √Æn repository.")
    # Pentru demo, oferim op»õiunea de a rula √Æn modul demo
    if st.sidebar.button("Rulare √Æn mod demo (fƒÉrƒÉ model real)"):
        st.sidebar.success("‚úÖ Mod demo activat!")
        model_loaded = True
        # Cream un model fake pentru demo
        from tensorflow.keras.models import Sequential
        from tensorflow.keras.layers import Dense
        model = Sequential([Dense(7, activation='softmax', input_shape=(224, 224, 3))])
        img_size = (224, 224)
        num_classes = 7
        if class_names is None or len(class_names) != num_classes:
            class_names = ["AlbinƒÉ", "G√¢ndac", "Fluture", "LibelulƒÉ", "FurnicƒÉ", "»ö√¢n»õar", "PƒÉianjen"]

# Zona de √ÆncƒÉrcare imagine - acum folosim o singurƒÉ coloanƒÉ
st.subheader("√éncarcƒÉ o imagine")

# Op»õiuni de √ÆncƒÉrcare
upload_method = st.radio(
    "MetodƒÉ de √ÆncƒÉrcare:", 
    options=["√éncarcƒÉ fi»ôier", "Folose»ôte camera"]
)

if upload_method == "√éncarcƒÉ fi»ôier":
    uploaded_file = st.file_uploader("Selecta»õi o imagine", type=["jpg", "jpeg", "png"])
else:
    uploaded_file = st.camera_input("FotografiazƒÉ o insectƒÉ")

# Procesare imagine »ôi predic»õie
if uploaded_file is not None:
    # Citire imagine
    image_pil = Image.open(uploaded_file)
    
    # Afi»ôare imagine originalƒÉ cu lƒÉ»õime limitatƒÉ
    image_container = st.container()
    with image_container:
        image_col, _ = st.columns([2, 1])
        with image_col:
            st.image(image_pil, caption="Imagine √ÆncƒÉrcatƒÉ", use_container_width=True)
    
    # Buton de analizƒÉ - mereu vizibil
    analyze_button = st.button("üîç IdentificƒÉ insecta", type="primary")
    
    if analyze_button:
        if model_loaded:
            with st.spinner("Se analizeazƒÉ imaginea..."):
                try:
                    # Predic»õie »ôi aplicare bounding box
                    result_img, predicted_class, confidence, all_predictions = predict_insect(
                        model, image_pil, class_names, img_size
                    )
                    
                    # Card cu rezultate
                    st.markdown(f"""
                    <div style="padding: 20px; border-radius: 10px; background-color: #1a405b; max-width: 600px;">
                        <h3 style="color: #1E88E5; margin-top: 0;">InsectƒÉ identificatƒÉ:</h3>
                        <h2>{predicted_class}</h2>
                        <p>Grad de √Æncredere: <b>{confidence*100:.2f}%</b></p>
                    </div>
                    """, unsafe_allow_html=True)
                    
                    # Info despre insectƒÉ
                    st.subheader("Alte predic»õii posibile:")
                    
                    # SortƒÉm predic»õiile »ôi afi»ôƒÉm top 3
                    sorted_predictions = sorted(
                        [(class_names[i], float(all_predictions[0][i])) for i in range(len(class_names))],
                        key=lambda x: x[1],
                        reverse=True
                    )
                    
                    # Afi»ôƒÉm top 3 predic»õii
                    for i, (name, prob) in enumerate(sorted_predictions[:3]):
                        st.markdown(f"{i+1}. **{name}**: {prob*100:.2f}%")
                    
                    # Afi»ôƒÉm un grafic cu top 5 predic»õii (limitat la 600px lƒÉ»õime)
                    st.subheader("Top 5 predic»õii:")
                    top5_dict = {name: prob for name, prob in sorted_predictions[:5]}
                    chart = st.bar_chart(top5_dict)
                except Exception as e:
                    st.error(f"Eroare la analizarea imaginii: {str(e)}")
                    st.info("Verifica»õi dacƒÉ modelul a fost √ÆncƒÉrcat corect »ôi dacƒÉ imaginea este validƒÉ.")
        else:
            st.error("‚ùå Modelul nu este √ÆncƒÉrcat! Verifica»õi calea cƒÉtre model.")
            st.info("Pute»õi folosi modul demo pentru a testa interfa»õa.")

# AdƒÉugare informa»õii √Æn sidebar
st.sidebar.header("Despre aplica»õie")
st.sidebar.info("""
    AceastƒÉ aplica»õie folose»ôte √ÆnvƒÉ»õare automatƒÉ pentru a identifica
    diferite tipuri de insecte din imagini. Modelul a fost antrenat
    pentru a recunoa»ôte mai multe specii de insecte.
    
    **Sfaturi pentru rezultate optime:**
    - Asigura»õi-vƒÉ cƒÉ insecta este √Æn centrul imaginii
    - Folosi»õi o imagine clarƒÉ, bine iluminatƒÉ
    - Evita»õi fundalurile complicate sau √ÆncƒÉrcate
""")
